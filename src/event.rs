use std::{mem, slice};
use std::convert::{TryFrom, TryInto};
use std::os::unix::io::{AsRawFd, FromRawFd};

use nix::errno::Errno;
use nix::unistd::{getpid, gettid, Pid};
use to_trait::To;

use crate::responses::Responses;

use super::{init, mark};
use super::common::FD;
use super::descriptor::Fanotify;
use super::libc::mark::mask::FAN_Q_OVERFLOW;
use super::libc::read::{FAN_EVENT_INFO_TYPE_DFID, FAN_EVENT_INFO_TYPE_DFID_NAME, FAN_EVENT_INFO_TYPE_FID, FAN_NOFD, fanotify_event_file_handle, fanotify_event_info_fid, fanotify_event_info_header, fanotify_event_metadata, FANOTIFY_METADATA_VERSION};
use super::libc::write::{FAN_ALLOW, FAN_AUDIT, FAN_DENY, fanotify_response};

use self::PermissionDecision::{Allow, Deny};

/// A thread or process id.
#[derive(Copy, Clone, Eq, PartialEq)]
pub enum Id {
    Pid(Pid),
    Tid(Pid),
}

impl Id {
    /// The process id if this contains one.
    pub fn pid(&self) -> Option<Pid> {
        match self {
            Self::Pid(pid) => Some(*pid),
            Self::Tid(_) => None,
        }
    }
    
    /// The thread id if this contains one.
    pub fn tid(&self) -> Option<Pid> {
        match self {
            Self::Pid(_) => None,
            Self::Tid(tid) => Some(*tid),
        }
    }
    
    /// The current thread or process id,
    /// as returned by [`getpid(2)`](https://man7.org/linux/man-pages/man2/getpid.2.html)
    /// or [`gettid(2)`](https://man7.org/linux/man-pages/man2/gettid.2.html).
    pub fn current(use_tid: bool) -> Self {
        if use_tid {
            Self::Tid(gettid())
        } else {
            Self::Pid(getpid())
        }
    }
}

/// The thread of process id of an event (see [`Id`]).
pub struct EventId {
    /// Whether this event was generated by the same thread or process that read the events.
    pub is_generated_by_self: bool,
    pub id: Id,
}

impl EventId {
    /// The process id if this contains one.
    pub fn pid(&self) -> Option<Pid> {
        self.id.pid()
    }
    
    /// The thread id if this contains one.
    pub fn tid(&self) -> Option<Pid> {
        self.id.tid()
    }
}

/// A regular file event just containing an [`FD`],
/// i.e., it is not a permission event and it's not a [`REPORT_FID`](init::Flags::REPORT_FID) event.
pub struct FileFD {
    pub fd: FD,
}

/// A filesystem id.  It uniquely represents any filesystem object.
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct FileSystemId {
    fsid: libc::fsid_t,
}

/// TODO there can be multiple of these per event, so need to handle that
#[derive(Copy, Clone, Eq, PartialEq)]
#[repr(u8)]
pub enum InfoType {
    Fid = FAN_EVENT_INFO_TYPE_FID,
    DFidName = FAN_EVENT_INFO_TYPE_DFID_NAME,
    DFid = FAN_EVENT_INFO_TYPE_DFID,
}

impl TryFrom<u8> for InfoType {
    type Error = u8;
    
    fn try_from(value: u8) -> std::result::Result<Self, Self::Error> {
        use InfoType::*;
        let this = match value {
            FAN_EVENT_INFO_TYPE_FID => Fid,
            FAN_EVENT_INFO_TYPE_DFID_NAME => DFidName,
            FAN_EVENT_INFO_TYPE_DFID => DFid,
            _ => return Err(value),
        };
        Ok(this)
    }
}

impl From<InfoType> for u8 {
    fn from(this: InfoType) -> Self {
        use InfoType::*;
        match this {
            Fid => FAN_EVENT_INFO_TYPE_FID,
            DFidName => FAN_EVENT_INFO_TYPE_DFID_NAME,
            DFid => FAN_EVENT_INFO_TYPE_DFID,
        }
    }
}

/// An opaque handle to a file.
/// This is like an absolute [`Path`](std::path::Path), except it is already resolved by the filesystem.
/// But unlike a [`RawFd`](std::os::unix::io::RawFd), it's not opened yet.
/// It can be opened by calling [`Self::open()`].
pub struct FileHandle<'a> {
    handle: &'a fanotify_event_file_handle,
}

impl FileHandle<'_> {
    /// Open the resolved file handle.
    /// Not implemented yet.
    pub fn open(&self) -> FD {
        todo!("{:p}", self.handle)
    }
}

/// A [`REPORT_FID`](init::Flags::REPORT_FID) file event.
/// Unlike a normal [`FileFD`] event, which contains an opened [`FD`],
/// it contains a [`FileSystemId`] and an unopened but resolved [`FileHandle`].
pub struct FileFID<'a> {
    pub info_type: InfoType,
    pub fsid: FileSystemId,
    pub handle: FileHandle<'a>,
}

/// A permission decision for a file event, either [`Allow`] or [`Deny`].
/// Defaults to [`Allow`].
#[derive(Eq, PartialEq, Copy, Clone)]
pub enum PermissionDecision {
    Allow,
    Deny,
}

// in case the user forgets to make a permission decision,
// we want to allow by default so everything doesn't get blocked by default
impl Default for PermissionDecision {
    fn default() -> Self {
        Allow
    }
}

impl From<PermissionDecision> for u32 {
    fn from(this: PermissionDecision) -> Self {
        match this {
            Allow => FAN_ALLOW,
            Deny => FAN_DENY,
        }
    }
}

/// Like a [`FileFD`] event, except it is a permission event
/// and thus you must make a permission decision.
///
/// Set [`Self::decision`] for the permission decision (it defaults to [`Allow`]).
/// [`Self::audit`] can also be set to tell the kernel to audit this permission decision.
/// The decision is written once all [`FilePermission`]s from this [`Fanotify::read`] call are dropped.
pub struct FilePermission<'a> {
    pub fd: FD,
    pub decision: PermissionDecision,
    pub audit: bool,
    written: bool,
    fanotify: &'a Fanotify,
}

impl<'a> FilePermission<'a> {
    fn new(fanotify: &'a Fanotify, fd: FD) -> Self {
        Self {
            fd,
            decision: PermissionDecision::default(),
            audit: false,
            written: false,
            fanotify,
        }
    }
    
    pub fn allow(&mut self) {
        self.decision = Allow;
    }
    
    pub fn deny(&mut self) {
        self.decision = Deny;
    }
    
    pub fn written(&self) -> bool {
        self.written
    }
    
    /// The raw [`fanotify_response`] representation of this [`FilePermission`].
    fn response(&self) -> fanotify_response {
        let audit = self.audit as u32 * FAN_AUDIT;
        fanotify_response {
            fd: self.fd.as_raw_fd(),
            response: self.decision.to::<u32>() | audit,
        }
    }
    
    fn just_write_immediately(&self) -> std::result::Result<(), Errno> {
        let response = self.response();
        let bytes_written = self.fanotify.fd.write(response.as_bytes())?;
        // a write this small should definitely succeed, so only try once
        match bytes_written {
            0 => Ok(()),
            _ => Err(Errno::EAGAIN),
        }
    }
    
    fn just_write_buffered(&self, responses: &mut Responses) {
        responses.add(&self.response());
    }
    
    pub fn write_immediately(&mut self) -> std::result::Result<(), Errno> {
        self.just_write_immediately()?;
        self.written = true;
        Ok(())
    }
    
    pub fn write_buffered(&mut self, responses: &mut Responses) {
        self.just_write_buffered(responses);
        self.written = true;
    }
}

/// Make sure the permission has always been written
impl Drop for FilePermission<'_> {
    fn drop(&mut self) {
        assert!(self.written);
    }
}

/// An enum of the different kinds of file events.
pub enum File<'a> {
    FD(FileFD),
    FID(FileFID<'a>),
    Permission(FilePermission<'a>),
}

impl<'a> File<'a> {
    /// Return the [`FD`](Self::FD) variant if it exists.
    pub fn fd(self) -> Option<FileFD> {
        match self {
            Self::FD(file) => Some(file),
            _ => None,
        }
    }
    
    /// Return the [`FID`](Self::FID) variant if it exists.
    pub fn fid(self) -> Option<FileFID<'a>> {
        match self {
            Self::FID(file) => Some(file),
            _ => None,
        }
    }
    
    /// Return the [`Permission`](Self::Permission) variant if it exists.
    pub fn permission(self) -> Option<FilePermission<'a>> {
        match self {
            Self::Permission(file) => Some(file),
            _ => None,
        }
    }
}

pub struct EventOf<FileT> {
    pub mask: mark::Mask,
    pub id: EventId,
    pub file: FileT,
}

/// A full file event
///
/// It contains:
/// * a [`Mask`](mark::Mask) specifying the type of event
/// * an [`EventId`] of who created the event
/// * the actual [`File`] event
///
/// Most of the [`Event`] is copied from
/// the raw [`fanotify_event_metadata`](crate::libc::read::fanotify_event_metadata)
/// and [`fanotify_event_info_fid`](crate::libc::read::fanotify_event_info_fid) structs,
/// but some fields, namely the [`FileHandle`],
/// cannot be copied because they are opaque, variable-length fields.
/// Thus, they are the only references in the [`Event`].
pub type Event<'a> = EventOf<File<'a>>;

impl<'a> Event<'a> {
    fn into_variant<FileT>(self, project: impl Fn(File<'a>) -> Option<FileT>) -> Option<EventOf<FileT>> {
        let Self {mask, id, file} = self;
        Some(EventOf {
            mask,
            id,
            file: project(file)?,
        })
    }
    
    /// Return the [`FileFD`] variant if it exists.
    pub fn fd(self) -> Option<EventOf<FileFD>> {
        self.into_variant(|it| it.fd())
    }
    
    /// Return the [`FileFID`] variant if it exists.
    pub fn fid(self) -> Option<EventOf<FileFID<'a>>> {
        self.into_variant(|it| it.fid())
    }
    
    /// Return the [`FilePermission`] variant if it exists.
    pub fn permission(self) -> Option<EventOf<FilePermission<'a>>> {
        self.into_variant(|it| it.permission())
    }
}

/// A buffer of [`Event`]s from one [`Fanotify::read`] call.
///
/// The individual [`Event`]s can only be iterated over because they are variable-length.
pub struct Events<'a> {
    fanotify: &'a Fanotify,
    id: Id,
    buffer: &'a mut Vec<u8>,
}

impl<'a> Events<'a> {
    /// Construct an [`Events`] by reading from a [`Fanotify`] into a given buffer.
    ///
    /// Returns an error only if the [`FD::read`] call returns an [`Errno`], which wraps [`libc::read`].
    pub(crate) fn read(
        fanotify: &'a Fanotify,
        buffer: &'a mut Vec<u8>,
    ) -> std::result::Result<Self, Errno> {
        buffer.clear();
        
        // want to use this, but it's unstable
        // reads.spare_capacity_mut()
        let read_buffer = {
            let ptr = buffer.as_mut_slice().as_mut_ptr();
            let len = buffer.capacity() * mem::size_of::<u8>();
            unsafe { slice::from_raw_parts_mut(ptr, len) }
        };
        let bytes_read = fanotify.fd.read(read_buffer)?;
        unsafe { buffer.set_len(bytes_read) };
        
        // id is read here for two reason
        // 1. it caches it for this set of events
        // 2. it ensures the id is correct, b/c if you read the id later,
        //    it could be different than when the read occurred
        let use_tid = fanotify.init.flags().contains(init::Flags::REPORT_TID);
        let id = Id::current(use_tid);
        
        let this = Self {
            fanotify,
            id,
            buffer,
        };
        Ok(this)
    }
}

/// A consuming [`Iterator`] over [`Events`].
pub struct EventIterator<'a> {
    events: Events<'a>,
    read_index: usize,
}

/// An error where the buffer for an [`Event`] field or struct is too short,
/// so the full field or struct cannot be read.
///
/// TODO document each error
#[derive(thiserror::Error, Debug)]
pub enum WhatIsTooShort {
    #[error("u32 fanotify_event_metadata::event_len field")]
    EventLenField,
    #[error("full event according to fanotify_event_metadata::event_len")]
    FullEvent,
    #[error("fanotify_event_metadata struct")]
    BaseEvent,
    #[error("fanotify_event_metadata struct and the fanotify_event_info_fid struct")]
    BaseAndFidEvent,
    #[error("fanotify_event_info_fid struct")]
    FidEvent,
}

/// An error from reading an [`Event`] from the buffer.
///
/// TODO document each error
#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error("the fanotify queue overflowed")]
    QueueOverflowed,
    #[error("the fanotify event has the wrong version so it can't be handled")]
    WrongVersion,
    #[error("the data read ({} bytes) is too short for a full event ({} bytes), specifically, the {}", .found, .expected, .what)]
    TooShort {
        what: WhatIsTooShort,
        found: usize,
        expected: usize,
    },
    #[error("the fanotify queue still overflowed even though {:?} was specified", init::Flags::UNLIMITED_QUEUE)]
    UnlimitedQueueButQueueStillOverflowed,
    #[error("{:?} requested but not received", init::Flags::REPORT_FID)]
    FidRequestedButNotReceived,
    #[error("{:?} not requested but received", init::Flags::REPORT_FID)]
    FidNotRequestedButReceived,
    #[error("a {:?} fanotify event was received for a permission event, meaning it lacks an fd for writing the permission", init::Flags::REPORT_FID)]
    FidReturnedForPermissionEvent,
    #[error("{:?} request but received an invalid or unknown info_type: {}", init::Flags::REPORT_FID, .info_type)]
    InvalidFidInfoType { info_type: u8 },
    #[error("received an invalid fd: {}", .fd)]
    InvalidFd { fd: FD },
}

pub type Result<'a> = std::result::Result<Event<'a>, Error>;

impl<'a> EventIterator<'a> {
    /// Like [`Self::next`] except it doesn't check if there is still more room in the events buffer
    /// so it returns a plain [`Result`] instead of an [`Option`]`<`[`Result`]`>`.
    ///
    /// This is only called from [`next`](EventIterator::next) so it's safe.
    /// It's just used to avoid nesting the [`Option`] and [`Result`].
    fn next_unchecked(&mut self) -> Result<'a> {
        use WhatIsTooShort::*;
        use Error::*;
        
        let remaining = &self.events.buffer.as_slice()[self.read_index..];
        
        let too_short = |what: WhatIsTooShort, expected: usize| -> std::result::Result<(), Error> {
            let found = remaining.len();
            if found < expected {
                return Err(TooShort {
                    what,
                    found,
                    expected,
                });
            } else {
                Ok(())
            }
        };
        
        let event_len_size = mem::size_of::<u32>();
        // in case we error here, we want read_index to be at the end,
        // so None is returned from next() next time
        self.read_index += event_len_size;
        too_short(EventLenField, event_len_size)?;
        self.read_index -= event_len_size;
        let ptr = remaining.as_ptr() as *const fanotify_event_metadata;
        let event = unsafe { &*ptr };
        let event_len = event.event_len as usize;
        self.read_index += event_len;
        too_short(FullEvent, event_len)?;
        too_short(BaseEvent, mem::size_of::<fanotify_event_metadata>())?;
        if event.vers != FANOTIFY_METADATA_VERSION {
            return Err(WrongVersion);
        }
        
        let flags = self.events.fanotify.init.flags();
        
        if event.mask & FAN_Q_OVERFLOW != 0 {
            let has_unlimited_queue = flags.contains(init::Flags::UNLIMITED_QUEUE);
            return Err(if has_unlimited_queue {
                UnlimitedQueueButQueueStillOverflowed
            } else {
                QueueOverflowed
            });
        }
        // type annotated for IDE, since from_bits_truncate is generated
        let mask: mark::Mask = mark::Mask::from_bits_truncate(event.mask);
        
        let has_no_fd = event.fd == FAN_NOFD;
        let requested_fid = flags.contains(init::Flags::REPORT_FID);
        let received_fid = event_len > mem::size_of::<fanotify_event_metadata>();
        let is_perm = mask.includes_permission();
        if requested_fid {
            if !received_fid {
                return Err(FidRequestedButNotReceived);
            } else {
                match (has_no_fd, is_perm) {
                    (true, true) => return Err(FidReturnedForPermissionEvent),
                    (false, false) => return Err(FidRequestedButNotReceived),
                    (true, false) => too_short(BaseAndFidEvent, 0
                        + mem::size_of::<fanotify_event_metadata>()
                        + mem::size_of::<fanotify_event_info_fid>(),
                    )?,
                    (false, true) => {}
                }
            }
        } else {
            if has_no_fd {
                return Err(QueueOverflowed);
            }
            if received_fid {
                return Err(FidNotRequestedButReceived);
            }
        }
        
        let raw_id = Pid::from_raw(event.pid);
        let own_id = self.events.id;
        let id = match own_id {
            Id::Pid(_) => Id::Pid(raw_id),
            Id::Tid(_) => Id::Tid(raw_id),
        };
        let id = EventId {
            is_generated_by_self: id == own_id,
            id,
        };
        
        let get_fd = || -> std::result::Result<FD, Error> {
            let fd = unsafe { FD::from_raw_fd(event.fd) };
            if !fd.check() {
                return Err(InvalidFd { fd });
            }
            Ok(fd)
        };
        
        let file = if is_perm {
            File::Permission(FilePermission::new(self.events.fanotify, get_fd()?))
        } else {
            if received_fid {
                // already checked that we have enough bytes for this
                let remaining = &remaining[mem::size_of::<fanotify_event_metadata>()..];
                let ptr = remaining.as_ptr() as *const fanotify_event_info_fid;
                let fid = unsafe { &*ptr };
                let info_type: InfoType = fid.hdr.info_type
                    .try_into()
                    .map_err(|info_type| InvalidFidInfoType { info_type })?;
                {
                    let found = fid.hdr.len as usize;
                    let expected = 0 +
                        mem::size_of::<fanotify_event_info_header>()
                        + mem::size_of::<libc::fsid_t>();
                    if found != expected {
                        return Err(TooShort {
                            what: FidEvent,
                            found,
                            expected,
                        });
                    }
                }
                File::FID(FileFID {
                    info_type,
                    fsid: FileSystemId {
                        fsid: fid.fsid,
                    },
                    handle: FileHandle {
                        handle: &fid.handle,
                    },
                })
            } else {
                File::FD(FileFD {
                    fd: get_fd()?,
                })
            }
        };
        
        let this = Event {
            mask,
            id,
            file,
        };
        Ok(this)
    }
}

impl<'a> Iterator for EventIterator<'a> {
    type Item = Result<'a>;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.events.buffer.len() <= self.read_index {
            return None;
        } else {
            Some(self.next_unchecked())
        }
    }
}

impl<'a> IntoIterator for Events<'a> {
    type Item = Result<'a>;
    type IntoIter = EventIterator<'a>;
    
    fn into_iter(self) -> Self::IntoIter {
        EventIterator { events: self, read_index: 0 }
    }
}

impl<'a> Events<'a> {
    /// An [`Iterator`] over all [`Result`]s, so including errors and [`Event`]s.
    pub fn all(self) -> impl Iterator<Item = Result<'a>> {
        self.into_iter()
    }
    
    /// An [`Iterator`] over all non-error [`Event`]s.
    pub fn ok(self) -> impl Iterator<Item = Event<'a>> {
        self.all().filter_map(|it| it.ok())
    }
    
    // TODO may want to check here based on fanotify flags if these are possible before cast-filtering
    
    /// An [`Iterator`] over all [`Event`]s containing a [`FileFD`].
    pub fn fds(self) -> impl Iterator<Item = EventOf<FileFD>> + 'a {
        self.ok().filter_map(|it| it.fd())
    }
    
    /// An [`Iterator`] over all [`Event`]s containing a [`FileFID`].
    pub fn fids(self) -> impl Iterator<Item = EventOf<FileFID<'a>>> {
        self.ok().filter_map(|it| it.fid())
    }
    
    /// An [`Iterator`] over all [`Event`]s containing a [`FilePermission`].
    pub fn permissions(self) -> impl Iterator<Item = EventOf<FilePermission<'a>>> {
        self.ok().filter_map(|it| it.permission())
    }
}
